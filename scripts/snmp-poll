#!/usr/bin/perl

# Copyright (C) 2000 Peter Whiting
# This module is free software; you can redistribute it and/or
# modify it under the terms of the GNU Library General Public
# License as published by the Free Software Foundation; either
#  version 2 of the License, or (at your option) any later version.
#
# This module is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public
# License along with this library; if not, write to the
# Free Software Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.

use strict;
use warnings;
use CIBH::Config qw/ $default_options /;
use CIBH::FileIO;
use CIBH::SNMP;
use Data::Dumper;
use Getopt::Long;
use Math::BigInt try => 'GMP';
use Module::Load;
$Data::Dumper::Indent = 1;

sub Main {
    my $opts = $default_options;

    GetOptions($opts,
               "config=s",      # config file
               "log=s",         # log file
               "config_path=s", # config directory
               "log_path=s",    # log directory
               "data_path=s",   # data directory
               "domain=s",      # domain name of router
               "rtr=s",         # router to examine
               "community=s",   # router community string
               "debug:i",       # debug messages
               "noaddress",     # don't collect addresses for aliases
               "accept=s",      # regexp for accepted interfaces
               "reject=s",      # regexp for rejected interfaces
               "noshutdown");   # don't poll shutdown interfaces?

    $opts->{debug}=1 if(defined $opts->{debug} and $opts->{debug}==0);
    $opts->{domain}=".$opts->{domain}"
        if defined $opts->{domain} and substr($opts->{domain},0,1) ne ".";

    if(not defined $opts->{rtr}){
        $opts->{rtr}=shift(@ARGV);
        $opts->{rtr}=~s/\.snmp\.config$//g;
        die "No router specified\n" if not $opts->{rtr};
    }
    $opts->{log} ||= "$opts->{log_path}/$opts->{rtr}.snmp.log";
    $opts->{config} ||= "$opts->{config_path}/$opts->{rtr}.snmp.config";

    if(ref $opts->{community} eq "HASH") {
        if($opts->{community}->{$opts->{rtr}}) {
            $opts->{community}=$opts->{community}->{$opts->{rtr}};
        } elsif ($opts->{community}->{default}) {
            $opts->{community}=$opts->{community}->{default};
        }
    }

    # we need to require our datastore and maybe connect to the database?
    my $ds = 'CIBH::'. $opts->{datastore};
    eval {
        Module::Load::load $ds;
    };

    die "Something went wrong with our load of '$ds': $@" if ($@);

    warn "Reading $opts->{config}\n" if $opts->{debug};
    my $config=require $opts->{config};
    # there should really only be one router per config, but loop for
    # fun anyway...
    foreach my $rtr (keys %{$config}) {
        warn "router: $rtr\n" if $opts->{debug};
        if(my $log=SnmpPollRouter($rtr,$config->{$rtr},$opts)) {
            my $out=Data::Dumper->Dump([$log],[qw(log)]);
            if (defined $opts->{log}) {
                my $file=$opts->{log};
                warn "Dumping config to $file\n" if $opts->{debug};
                CIBH::FileIO::overwrite($file,$out);
            } else {
                print $out;
            }
        }
    }
}

# This is the beef - it will get all OIDS we are interested in
# for the router name passed as the first command line argument,
# then it will build a SNMP packet to the router to get the values.
# Once the packet returns it will execute the commands specified in
# the database for each returned MIB/value pair.

sub SnmpPollRouter {
    my($rtr,$config,$opts)=(@_);
    my $log;

    my $snmp = CIBH::SNMP->new($rtr, $opts);

    my ($oids,$metrics);
    foreach my $metric (keys %{$config}) {
        if (defined $config->{$metric}->{mib}) {
            my $mib=$config->{$metric}->{mib};
            push @$oids,[$mib];
            $metrics->{$mib}=$metric;
            warn "pushing $mib and $metric\n" if defined $opts->{debug};
        }
    }

    my $vars = $snmp->query($oids);
    foreach my $line (@$vars) {
        my $tag = $snmp->translate($line,$metrics);
        my $hash=$config->{$metrics->{$tag}};
        my $file="$rtr/$metrics->{$tag}";
        $hash->{value}=Math::BigInt->new($line->val);
        $hash->{spikekiller}=$opts->{spikekiller};
        $hash->{file}="$opts->{data_path}/$file";
        warn "eval $hash->{command}" if($opts->{debug});
        my $value = eval $hash->{command};
        if($hash->{max}) {
            my $usage=$value*8/$hash->{max};
            # once we get here we should not need BigInt anymore, and we
            # need a real number to pass to Data::Dumper
            $usage=$usage->numify() if ref($usage) eq 'Math::BigInt';
            $log->{$file}->{usage}=$usage;
        }
        $log->{$file}->{host}=$rtr;
        $log->{$file}->{desc}=$hash->{desc} if $hash->{desc};
        $log->{$file}->{addr}=$hash->{addr} if $hash->{addr};
        $log->{$file}->{prefix}=$hash->{prefix} if $hash->{prefix};
    }
    return $log;
}

while (@ARGV) {Main};
