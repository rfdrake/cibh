#!/usr/bin/perl

# Copyright (C) 2000 Peter Whiting
# This module is free software; you can redistribute it and/or
# modify it under the terms of the GNU Library General Public
# License as published by the Free Software Foundation; either
#  version 2 of the License, or (at your option) any later version.
#
# This module is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public
# License along with this library; if not, write to the
# Free Software Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.

use strict;
use warnings;
use CIBH::Config qw/ $default_options /;
use CIBH::DS;
use SNMP::Effective;
use Getopt::Long;
use Math::BigInt try => 'GMP';

sub Main {
    my $opts = $default_options;

    GetOptions($opts,
               "config=s",      # config file
               "log=s",         # log file
               "stdout:i",      # dump to stdout instead of log file
               "config_path=s", # config directory
               "log_path=s",    # log directory
               "data_path=s",   # data directory
               "domain=s",      # domain name of router
               "rtr=s",         # router to examine
               "community=s",   # router community string
               "debug:i",       # debug messages
               "noaddress",     # don't collect addresses for aliases
               "accept=s",      # regexp for accepted interfaces
               "reject=s",      # regexp for rejected interfaces
               "noshutdown");   # don't poll shutdown interfaces?

    $opts->{debug}=1 if(defined $opts->{debug} and $opts->{debug}==0);
    $opts->{domain}=".$opts->{domain}"
        if defined $opts->{domain} and substr($opts->{domain},0,1) ne ".";

    my $ds = CIBH::DS::load_ds($opts->{datastore});

    my $snmp = SNMP::Effective->new( max_sessions => 50,
                                     master_timeout => 5,
                                     arg => {
                                        Version => '2c',
                                        Community => $opts->{community},
                                        UseSprintValue => 1,
                                     },
                                   );

    push(@ARGV, $opts->{rtr}) if ($opts->{rtr});
    die "No router specified\n" if not (@ARGV);
    foreach my $r (@ARGV) {
        $r=~s/\.snmp\.config$//g;

        my $config=CIBH::Config::load_snmp_config($r,$opts);

        # there should really only be one router per config, but loop for
        # fun anyway...
        foreach my $rtr (keys %{$config}) {
            warn "router: $rtr\n" if $opts->{debug};
            SnmpPollRouter($snmp,$rtr,$config->{$rtr},$opts);
        }
    }
    $snmp->execute;
}

=head2 SnmpPollRouter
    SnmpPollRouter($snmp,$host,$config,$opts);

This will figure out what OIDS we are interested in by looking at the config,
then add the router to the schedule to be polled.  Once the polling completes
the values are processed via the $store callback.

=cut

sub SnmpPollRouter {
    my($snmp,$rtr,$config,$save, $opts)=(@_);

    my $oids;
    our $metrics; # needed for translate() below, which is needed by the $store callback
    foreach my $metric (keys %{$config}) {
        if (defined $config->{$metric}->{oid}) {
            my $oid=$config->{$metric}->{oid};
            push @$oids,$oid;
            $metrics->{$oid}=$metric;
            warn "pushing $oid and $metric\n" if defined $opts->{debug};
        }
    }

    sub translate {
        my $oid = shift;
        my $index = shift;

        $oid =~ s/^\.//;  # shouldn't be needed..
        return $metrics->{$oid} if ($metrics->{$oid});
        return $metrics->{"$oid.$index"} if (defined($metrics->{"$oid.$index"}));

        my $tag = SNMP::Effective::make_name_oid($oid);
        return $metrics->{$tag} if (defined($metrics->{$tag}));
        return $metrics->{"$tag.$index"} if (defined($metrics->{"$tag.$index"}));
        warn "couldn't find metric for OID $oid/$tag\n";
    }

    # I don't think there are concurrency issues with this at the moment, so
    # we can save directly from the callback.  If you add more mibs to poll
    # then you may need to wait until all the data is collected before doing
    # the save commands.
    my $store = sub {
        my ($host, $error) = @_;
        my $log = {};

        if($error) {
             warn "$host failed with this error: $error" if ($opts->{debug});
             return;
        }

        while(my ($oid, $val) = each %{$host->data}) {
            foreach my $idx (keys %$val) {
                my $tag = translate($oid,$idx);
                my $hash=$config->{$tag};
                my $file="$rtr/$tag";
                $hash->{value}=Math::BigInt->new($val->{$idx});
                $hash->{spikekiller}=$opts->{spikekiller};
                $hash->{file}="$opts->{data_path}/$file";
                warn "eval $hash->{command}" if($opts->{debug});
                my $value = eval $hash->{command};
                if($hash->{max}) {
                    my $usage=$value/$hash->{max};
                    # once we get here we should not need BigInt anymore, and we
                    # need a real number to pass to Data::Dumper
                    $usage=$usage->numify() if ref($usage) eq 'Math::BigInt';
                    $log->{$file}->{usage}=$usage;
                }
                $log->{$file}->{host}=$rtr;
                $log->{$file}->{desc}=$hash->{desc} if $hash->{desc};
                $log->{$file}->{addr}=$hash->{addr} if $hash->{addr};
                $log->{$file}->{prefix}=$hash->{prefix} if $hash->{prefix};
            }
        }
        CIBH::Config::save_file("$opts->{log_path}/$host.snmp.log",$log,'log',$opts);
    };

    $snmp->add(dest_host => $rtr, callback => $store, get => $oids );
}

Main;
