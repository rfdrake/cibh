#!/usr/bin/perl

# Copyright (C) 2000 Peter Whiting
# This module is free software; you can redistribute it and/or
# modify it under the terms of the GNU Library General Public
# License as published by the Free Software Foundation; either
#  version 2 of the License, or (at your option) any later version.
#
# This module is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public
# License along with this library; if not, write to the
# Free Software Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.

use strict;
use CIBH::Config qw/ $default_options /;
use CIBH::Store;
use CIBH::Datafile;
use Data::Dumper;
use SNMP;
use Getopt::Long;
use Math::BigInt try => 'GMP';
$Data::Dumper::Indent = 1;

my $max64 = Math::BigInt->new(2)->bpow(64);

sub Main {
    my $opts;

    $opts={log_path=>".",
           config_path=>".",
           data_path=>".",
           %{$default_options} };

    GetOptions($opts,
               "config=s",      # config file
               "log=s",         # log file
               "config_path=s", # config directory
               "log_path=s",    # log directory
               "data_path=s",   # data directory
               "domain=s",      # domain name of router
               "rtr=s",         # router to examine
               "community=s",   # router community string
               "debug:i",       # debug messages
               "noaddress",     # don't collect addresses for aliases
               "accept=s",      # regexp for accepted interfaces
               "reject=s",      # regexp for rejected interfaces
               "noshutdown");   # don't poll shutdown interfaces?

    $opts->{debug}=1 if(defined $opts->{debug} and $opts->{debug}==0);
    $opts->{domain}=".$opts->{domain}"
        if defined $opts->{domain} and substr($opts->{domain},0,1) ne ".";

    if(not defined $opts->{rtr}){
        $opts->{rtr}=shift(@ARGV);
        $opts->{rtr}=~s/\.snmp\.config$//g;
        die "No router specified\n" if not $opts->{rtr};
    }
    if(not defined $opts->{log}){
        $opts->{log}="$opts->{log_path}/$opts->{rtr}.snmp.log";
    }
    if(not defined $opts->{config}){
        $opts->{config}="$opts->{config_path}/$opts->{rtr}.snmp.config";
    }
    if(ref $opts->{community} eq "HASH") {
        if($opts->{community}->{$opts->{rtr}}) {
            $opts->{community}=$opts->{community}->{$opts->{rtr}};
        } elsif ($opts->{community}->{default}) {
            $opts->{community}=$opts->{community}->{default};
        }
    }

    warn "Reading $opts->{config}\n" if $opts->{debug};
    my $config=require $opts->{config};
    # there should really only be one router per config, but loop for
    # fun anyway...
    foreach my $rtr (keys %{$config}) {
        warn "router: $rtr\n" if $opts->{debug};
        if(my $log=SnmpPollRouter($rtr,$config->{$rtr},$opts)) {
            my $out=Data::Dumper->Dump([$log],[qw(log)]);
            if (defined $opts->{log}) {
                my $file=$opts->{log};
                warn "Dumping config to $file\n" if $opts->{debug};
                unlink $file;
                my $file=CIBH::Datafile::Open($file);
                print $file $out;
            } else {
                print $out;
            }
        }
    }
}

sub Store {
    my($hash)=(@_);
    CIBH::Store::Store("$hash->{file}.text",$hash->{value});
}
sub GaugeAppend {
    my($hash)=(@_);
    CIBH::Store::GuageAppend($hash->{file},$hash->{value});
}
# these actually change to bits/sec with {value}*8, so technically they aren't
# octets anymore.  We should probably switch it back to value then make the
# displayed value *8, but that would be a breaking change.

# maybe we could change the file naming convention with the new version so
# backword compatibility could be maintained? I don't think anyone is using
# this right now besides us..
sub OctetsAppend64 {
    my($hash)=(@_);
    $hash->{value}=CIBH::Store::CounterAppend($hash->{file},$hash->{value}*8,$hash->{spikekiller}, $max64);
}
sub OctetsAppend {
    my($hash)=(@_);
    $hash->{value}=CIBH::Store::CounterAppend($hash->{file},$hash->{value}*8,$hash->{spikekiller});
}

# This is the beef - it will get all MIBS we are interested in
# for the router name passed as the first command line argument,
# then it will build a SNMP packet to the router to get the values.
# Once the packet returns it will execute the commands specified in
# the database for each returned MIB/value pair.

sub SnmpPollRouter {
    my($rtr,$config,$opts)=(@_);
    my $size=$config->{size};
    my $log;
    $size=50 if not $size;

    warn "No community\n" and return if(not $opts->{community});

    my (@var,$files);
    foreach my $file (keys %{$config}) {
        if (defined $config->{$file}->{mib}) {
            my $mib=$config->{$file}->{mib};
            push @var,[$mib];
            $files->{$mib}=$file;
            warn "pushing $mib and $file\n" if defined $opts->{debug};
        }
    }

    my $session=SNMP::Session->new(DestHost => $rtr.$opts->{domain},
                                   Version=>2,
				   Community => $opts->{community},
				   UseSprintValue => 1,# might not want this
				   RetryNoSuch => 1);

    warn "bombed session to $rtr\n", return if not $session;


    # limit the size of the SNMP query - the big ones don't return...
    my @tmp; # this can probably be moved in scope
    while(@var) {
        my($vars)=SNMP::VarList->new(@tmp=splice(@var,0,$size));
        $session->get($vars);

        # timeouts can be caused by many things.  I make the optimistic assumption
        # that we have connectivity (or the config wouldn't have been built) so
        # it must be the query size is too big.  Drop it in half and try again.
        # If it eventually works we should store this info (there is a place
        # holder in host_info, but I haven't started using it yet.)

        # in reality, almost all timeouts are caused by down hosts.  Ping
        # before poll would be a better optimization, but not everyone can
        # ping hosts that they poll.  It would be nice to have an
        # authoritative NO from the host, but without that the second best
        # thing we can do is parallelize the queries.

        # I really wish there was a super fast, threaded daemon that we could
        # hand things over to and say poll these hosts and these mibs and give
        # us back the info when you're done.  Something like what rabbitmq and
        # friends do except in the NMS world.  You just throw it on a bus and
        # let the thing that does it handle it, then give it back to you.
        if($session->{ErrorStr}){
            if($session->{ErrorStr}=~/Timeout/ and $size>=2) {
                $size=int($size/2);
                unshift(@var,@tmp);
                warn "Changed query size to $size for $rtr.\n";
            } else {
                warn "Error with snmp get on $rtr: " .
                    "$session->{ErrorStr}\n".
                        "Be sure you have connectivity to this host\n" .
                            "and snmp access is allowed from this source.\n";
                return;
            }
        } else {
            foreach my $line (@$vars) {
                my $tag=$line->tag;
                my $index='';
                $index = '.'.$line->iid if ($line->iid ne '');
                # append the Index if it exists.
                $tag.=$index;

                if (not defined $files->{$tag}) {
                    $tag=SNMP::translateObj($line->tag,0);
                    $tag.=$index;   # translateObj strips the index again
                }
                $tag=~s/^\.//;
                if(not defined $files->{$tag}) {
                    warn "couldn't find mib for $tag\n";
                    next;
                }

                if (not defined $line->val) {
                    warn "Deactivating $rtr $tag\n";
                    warn " figure this out eventually...\n";
                    next;
                }
                my $hash=$config->{$files->{$tag}};
                my $file="$rtr/$files->{$tag}";
                $hash->{file}="$opts->{data_path}/$file";
                $hash->{value}=Math::BigInt->new($line->val);
                warn "eval $hash->{command}" if($opts->{debug});
                $hash->{spikekiller}=$opts->{spikekiller};
                my $value = eval $hash->{command};
                # once we get here we should not need BigInt anymore, and we
                # need a real number to pass to Data::Dumper
                $value=$value->numify() if ref($value) eq 'Math::BigInt';
                if($hash->{max}) {
                    $log->{$file}->{usage}=$value/$hash->{max};
                    $log->{$file}->{host}=$rtr;
                    $log->{$file}->{desc}=$hash->{desc} if $hash->{desc};
                    $log->{$file}->{addr}=$hash->{addr} if $hash->{addr};
                    $log->{$file}->{prefix}=$hash->{prefix} if $hash->{prefix};
                }
            }
        }
    }
    return $log;
}

while (@ARGV) {Main};
