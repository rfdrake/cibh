#!/usr/bin/perl

use strict;
use warnings;
use AE;
use CIBH::SNMP;
use SNMP::OID::Translate qw ( translate translateObj );
use Getopt::Long;
use CIBH::Config qw/ $default_options /;

sub Main {
    my $opts = $default_options;

    GetOptions($opts,
               "config=s",      # config file to store in
               "config_path=s",   # base directory
               "domain=s",      # domain name of router
               "rtr=s",         # router to examine
               "community=s",   # router community string
               "debug:i",       # debug messages
               "noaddress",     # don't collect addresses for aliases
               "accept=s",      # regexp for accepted interfaces
               "reject=s",      # regexp for rejected interfaces
               "datastore=s",   # Datastore type (default = Datafile)
               "noshutdown");   # don't poll shutdown interfaces?

    $opts->{debug}=1 if(defined $opts->{debug} and $opts->{debug}==0);
    $opts->{domain}=".$opts->{domain}"
        if defined $opts->{domain} and substr($opts->{domain},0,1) ne '.';

    push(@ARGV, $opts->{rtr}) if (defined($opts->{rtr}));
    die "No router specified\n" if not (@ARGV);

    my $cv = AE::cv;
    my $values = {};
    my $status = 0;
    foreach my $rtr (@ARGV) {
        $values->{$rtr} = {
            # default to old cisco cpu values if we don't get something from the host
            'cpu.1m' => '1.3.6.1.4.1.9.2.1.57.0',
            'cpu.5m' => '1.3.6.1.4.1.9.2.1.58.0',
        };
        $status += GetSNMPInfo($cv,$rtr,$opts,$values);
    }

    # if some of the SNMP connections succeeded then block until they are
    # done, then write the configurations.
    if ($status) {
        $cv->recv;

        foreach my $host (keys %$values) {
            my $config = Config($host, $opts, $values->{$host});
            CIBH::Config::save_file("$opts->{config_path}/$host.snmp.config",$config,'config',$opts);
        }
    }
}

# too many ternaries?  You be the judge!
sub convert_address {
    my $in = shift;
    my $size = shift;
    return if ($size != 16 && $size != 4);

    my $ipv6 = $size == 16 ? 1 : 0;
    my $sep = $ipv6 ? ':' : '.';
    my $modulus = $ipv6 ? 2 : 1;
    my $ip = '';
    for(1..$size) {
        $ip .= sprintf($ipv6 ? "%02x%s" : "%s%s", $in->[$_-1], ($_ % $modulus == 0 && $_ != $size) ? $sep : '');
    }
    return $ip;
}


sub parse_prefix {
    my $addr = shift;
    return if ($addr eq '.0.0');

    $addr =~ s/^\.1\.3\.6\.1\.2\.1\.4\.32\.1\.5\.//;
    my $in = [split(/\./,$addr)];
    my $index = shift @$in;
    my $unk = shift @$in;
    my $size = shift @$in;
    my $cidr = pop @$in;
    my $ip = convert_address($in, $size);
    return $index, "$ip/$cidr";
}

sub parse_ifindex {
    my $oid = shift;
    my $ifindex = shift;
    my $in = [split(/\./, $oid)];
    my $unk = shift @$in;
    my $size = shift @$in;
    my $addr = convert_address($in, $size);

    return $ifindex, $addr;
}

sub GetSNMPInfo {
    my($cv,$rtr,$opts,$values)=(@_);
    $rtr .= $opts->{domain} if ($opts->{domain});

    my $oidmap = {
        # 1min                            => 5min
        '1.3.6.1.4.1.9.2.1.57.0'          => '1.3.6.1.4.1.9.2.1.58.0', # old cisco
        '1.3.6.1.4.1.9.9.109.1.1.1.1.7.1' => '1.3.6.1.4.1.9.9.109.1.1.1.1.8.1', # new cisco
    };

    # because this is called as data arrives, we can't run the Config()
    # sub at the end.  We might not have all the data yet.  We'll need to wait
    # until after $cv->recv
    my $store = sub {
        my $session = shift;
        my $host = $session->hostname;
        my $results = $session->var_bind_list;

        if(!defined $results) {
            warn "$host failed with this error: ". $session->error if $opts->{debug};
            $cv->end;
            return;
        }

        while(my ($oid, $val) = each %{$results}) {
            next if ($val eq 'noSuchInstance' || $val eq 'noSuchObject');
            # split into only two variables even if there are more dots
            my ($tag,$idx) = split(/\./, translateObj($oid),2);
            if ($oidmap->{$oid}) {
                $values->{$host}{'cpu.1m'}=$oid;
                $values->{$host}{'cpu.5m'}=$oidmap->{$oid};
                warn "Using oid $oid and $oidmap->{$oid}\n" if($opts->{debug});
                next;
            }
            if ($tag eq 'ipAddressPrefix') {
                my ($index, $prefix) = parse_prefix($val);
                # only allowing ipv4 right now
                #push(@{$values->{$host}{$index}{prefix}},$prefix) if ($prefix);
                if ($prefix && $prefix =~ /^\d+\.\d+\.\d+\.\d+/) {
                    $values->{$host}{$index}{prefix}=$prefix;
                }
            } elsif ($tag eq 'ipAddressIfIndex') {
                my ($index, $addr) = parse_ifindex($idx,$val);
                #push(@{$values->{$host}{$index}{addr}},$addr) if ($addr);
                if ($addr && $addr =~ /^\d+\.\d+\.\d+\.\d+/) {
                    $values->{$host}{$index}{addr}=$addr;
                }
            # everything else should be treated as an interface statistic
            } else {
                push(@{$values->{$host}{indexes}}, $idx) if (!$values->{$host}{$idx}{ifIndex});
                $values->{$host}{$idx}{ifIndex}=$idx;
                $values->{$host}{$idx}{$tag}=$val;
            }
        }
        $cv->end;
    };

    my $oids = [ '1.3.6.1.4.1.9.9.109.1.1.1.1.7.1',   # New Cisco
                 '1.3.6.1.4.1.9.2.1.57.0',            # Old Cisco
                 '1.3.6.1.4.1.20858.10.13.1.1.1.4',   # Casa
               ];

    my $iftable_tags = [ 'ifDescr','ifSpeed','ifHighSpeed','ifAdminStatus', 'ifAlias' ];
    my $ipaddr_tags =  [ 'ipAddressIfIndex', 'ipAddressPrefix' ];

    my $snmp = CIBH::SNMP->new( hostname => $rtr, %$opts, cv => $cv );
    return 0 if !defined $snmp;
    $snmp->queue({ -varbindlist => $oids, -callback => $store, cv => $cv });
    $snmp->queue({ -columns => translate($iftable_tags), -callback => $store, cv => $cv });
    $snmp->queue({ -columns => translate($ipaddr_tags), -callback => $store, cv => $cv });
    return 1;
}

sub Config {
    my($host,$opts,$values)=(@_);

    my $config = {};
    warn "Using config generation on $host\n" if($opts->{debug});

    $config->{$host}->{'cpu.1m'}={
        oid=> $values->{'cpu.1m'},
        command=> 'CIBH::DS::' . $opts->{datastore} . '::GaugeAppend',
        cpuave=>1,
        max=>100,
        file=>'cpu.1m',
    };

    if (defined($values->{'cpu.5m'})) {
        $config->{$host}->{'cpu.5m'}={
            oid=> $values->{'cpu.5m'},
            command=> 'CIBH::DS::' . $opts->{datastore} . '::GaugeAppend',
            cpuave=>5,
            max=>100,
            file=>'cpu.5m',
        };
    }

    foreach my $index (@{$values->{indexes}}) {
        my $iface = $values->{$index}{'ifDescr'};
        my $speed = $values->{$index}{'ifSpeed'};
        my $highspeed = $values->{$index}{'ifHighSpeed'};
        my $stat = $values->{$index}{'ifAdminStatus'};
        my $desc = $values->{$index}{'ifAlias'};
        my $addr = $values->{$index}{'addr'};
        my $prefix = $values->{$index}{'prefix'};

        next if (!$iface);

        $desc=~s/\'/\\\'/s;
        $iface=~ tr/ \//./s;

        next if not AllowInterface($opts,$host,"$iface $desc",$stat,$speed);

        my $if_in='1.3.6.1.2.1.2.2.1.10';  # ifInOctets
        my $if_out='1.3.6.1.2.1.2.2.1.16'; # ifOutOctets
        my $command = 'CIBH::DS::' . $opts->{datastore} . '::OctetsAppend';
        if (defined($highspeed)) {
            $if_in="1.3.6.1.2.1.31.1.1.1.6"; # ifHCInOctets
            $if_out="1.3.6.1.2.1.31.1.1.1.10"; # ifHCOutOctets
            $speed=$highspeed * 1_000_000;
            $command = 'CIBH::DS::' . $opts->{datastore} .'::OctetsAppend64';
        }

        $config->{$host}->{"$iface.in"}={
            oid=>"$if_in.$index",
            command=>$command,
            desc=>$desc,
            iface=>$iface,
            addr=>$addr,
            prefix=>$prefix,
            max=>$speed,
            file=>"$iface.in",
        };

        $config->{$host}->{"$iface.out"}={
            oid=>"$if_out.$index",
            command=>$command,
            iface=>$iface,
            desc=>$desc,
            addr=>$addr,
            prefix=>$prefix,
            max=>$speed,
            file=>"$iface.out",
        };
    }
    return $config;
}

sub AllowInterface {
    my($opts,$rtr,$desc,$stat,$speed)=(@_);

    warn "Interface: $rtr $desc speed=$speed stat=$stat\n"
        if($opts->{debug});
    if ($opts->{accept} and not $desc=~/$opts->{accept}/) {
        warn "can not accept $rtr $desc\n" if ($opts->{debug});
        return 0;
    }

    if ($opts->{reject} and $desc=~/$opts->{reject}/) {
        warn "rejecting $rtr $desc\n" if($opts->{debug});
        return 0;
    }

    if ($opts->{noshutdown} and $stat!=1)  {
        warn "ignoring shutdown interface $rtr $desc\n" if ($opts->{debug});
        return 0;
    }

    if ($speed==0) {
        warn "speed is zero, reject $rtr $desc\n" if ($opts->{debug});
        return 0;
    }

    warn "Accepted interface\n" if ($opts->{debug});

    return 1;
}

Main;
