#!/usr/bin/perl

use strict;
use Data::Dumper;
use IO::File;
use SNMP;
use Getopt::Long;
use Socket;
use vars qw/ $default_options /;
$Data::Dumper::Indent = 1;

sub Main {
    my($opts);

    if (-r "$ENV{HOME}/.cibhrc") {
        require "$ENV{HOME}/.cibhrc";
    }       
    $opts={config_path=>".",
           %{$default_options}};

    GetOptions($opts,
               "config=s",      # config file to store in
               "config_path=s",   # base directory
               "domain=s",      # domain name of router
               "rtr=s",         # router to examine
               "community=s",   # router community string
               "debug:i",       # debug messages
               "noaddress",     # don't collect addresses for aliases
               "accept=s",      # regexp for accepted interfaces
               "reject=s",      # regexp for rejected interfaces
               "noshutdown");   # don't poll shutdown interfaces?

    $opts->{debug}=1 if(defined $opts->{debug} and $opts->{debug}==0);
    $opts->{domain}=".$opts->{domain}"
        if defined $opts->{domain} and substr($opts->{domain},0,1) ne ".";
    if(not defined $opts->{rtr}){  
        $opts->{rtr}=shift(@ARGV);
        die "No router specified\n" if not $opts->{rtr};
        $opts->{config}="$opts->{config_path}/$opts->{rtr}.snmp.config";
    }
    if(ref $opts->{community} eq "HASH") {
        if($opts->{community}->{$opts->{rtr}}) {
            $opts->{community}=$opts->{community}->{$opts->{rtr}};
        } elsif ($opts->{community}->{default}) {
            $opts->{community}=$opts->{community}->{default};
        }
    }
    if(my $config=BuildSnmpConfig($opts)) {
        my $out=Data::Dumper->Dump([$config],[qw(config)]);
        if (defined $opts->{config}) {
            my $file=$opts->{config};
            warn "Dumping config to $file\n" if $opts->{debug};
            unlink $file; # might want to write to a temp name instead - race
            my $file=Open($file);
            print $file $out;
        } else {        
            print $out;
        }
    }
}

sub Open {
    my($filename,$flags)=(@_);
    $flags=O_RDWR|O_CREAT unless $flags;
    my($handle)=new IO::File $filename, $flags;
    if(!defined $handle) {
        if($!=~/directory/) {
            my $dir;
            if((($dir)=($filename=~/(.*)\/[^\/]+$/)) && ($dir ne ".")){
                warn "Creating directory $dir\n";
                system("mkdir -p $dir");
                $handle=new IO::File $filename,$flags;
            }
        }
    }
    return $handle;
}


sub BuildSnmpConfig {
    my($opts)=(@_);
    my $rtr=$opts->{rtr};
    warn "No community for $rtr" and return if(not $opts->{community});
    
    my($session)=new SNMP::Session(DestHost=>$rtr.$opts->{domain},
                                   Community=>$opts->{community}, Version=>2);
    if(!defined $session) {
        warn "Couldn't get session to $rtr.\n";
        return;
    }

    my($sys)=$session->get([["sysDescr",0]]);
    if($session->{ErrorStr}){
        warn "Couldn't contact $rtr: $session->{ErrorStr}\n".
                "be sure you have the communty string right.";
        return;
    }
    return Config($session,$opts,'1.3.6.1.4.1.20858.10.13.1.1.1.4') if $sys =~/CASA/;
    return Config($session,$opts);
}

sub Config {
    my($session,$opts,$cpu_one_min,$cpu_five_min)=(@_);

    # if they didn't give us a 5min oid then copy the 1min one.
    if (defined($cpu_one_min) && !defined($cpu_five_min)) {
       $cpu_five_min=$cpu_one_min;
    } else {
        $cpu_five_min ||= '.1.3.6.1.4.1.9.9.109.1.1.1.1.8'; # cisco cpmCPUTotal5minRev
        $cpu_one_min ||= '.1.3.6.1.4.1.9.9.109.1.1.1.1.7';  # cisco cpmCPUTotal1minRev
    }
    my($if_in)="1.3.6.1.2.1.2.2.1.10";  # ifInOctets
    my($if_out)="1.3.6.1.2.1.2.2.1.16"; # ifOutOctets
    my $rtr=$opts->{rtr};
    my $config={};
    warn "Using config generation on $rtr\n" if($opts->{debug});
    
    $config->{$rtr}->{"cpu.1m"}={ 
        mib=>$cpu_one_min,
        command=>"GaugeAppend(\$hash)",
        cpuave=>1,
        max=>100
        };
    
    $config->{$rtr}->{"cpu.5m"}={
        mib=>$cpu_five_min,
        command=>"GaugeAppend(\$hash)",
        cpuave=>5,
        max=>100 
        };

# I'm pretty sure this is never used, but I'm leaving it commented as an
# example of Store().  I was trying to decide if Store() should have the file
# headers but couldn't figure out a way to detect if it did or not without
# adding magic numbers or some sequence to the beginning of the file.
# then I realized it might not matter.
    
#     $config->{$rtr}->{"uptime"}={ 
#         mib=>"system.sysUpTime.0",
#         command=>"Store(\$hash)",
#         uptime=>1
#         };
     
    # ifDescr is the interface name, $desc is the mib for the
    # description string.   
    
    my $addrs=GetAddresses($session) if not defined $opts->{noaddress};
    my ($vars)=new SNMP::VarList(["ifIndex"],["ifDescr"],["ifSpeed"],["ifHighSpeed"],
                                ["ifAdminStatus"],["ifAlias"]);
    
    while(my($index,$iface,$speed,$highspeed,$stat,$desc)=$session->getnext($vars) and
          $vars->[0]->tag =~ /ifIndex/ and 
          not $session->{ErrorStr}) {
        
        $desc=~s/\'/\\\'/s;
        $iface=~ tr/ \//./s;

        next if not AllowInterface($opts,"$iface $desc",$stat,$speed);
        my ($addr,$prefix)=@{$addrs->{$index}} if defined $addrs->{$index};

        my $command = 'OctetsAppend($hash)';
        if (defined($highspeed)) {
            $if_in="1.3.6.1.2.1.31.1.1.1.6"; # ifHCInOctets
            $if_out="1.3.6.1.2.1.31.1.1.1.10"; # ifHCOutOctets
            $speed=$highspeed * 1_000_000;
            $command = 'OctetsAppend64($hash)';
        }
	
        $config->{$rtr}->{"$iface.in"}={
            mib=>"$if_in.$index",
            command=>$command,
            desc=>$desc,
            iface=>$iface,
            addr=>$addr,
            prefix=>$prefix,
            max=>$speed,
            };
	
        $config->{$rtr}->{"$iface.out"}={
            mib=>"$if_out.$index",
            command=>$command,
            iface=>$iface,
            desc=>$desc,
            addr=>$addr,
            prefix=>$prefix,
            max=>$speed,
            };
    }
    return $config;
}

sub AllowInterface {
    my($opts,$desc,$stat,$speed)=(@_);
    my $rtr=$opts->{rtr};
    
    warn "Interface: $rtr $desc speed=$speed stat=$stat\n" 
        if($opts->{debug}>1);
    if($opts->{accept} and not $desc=~/$opts->{accept}/) {
        warn "can not accept $rtr $desc\n" if($opts->{debug});
        return 0;
    }
    
    if($opts->{reject} and $desc=~/$opts->{reject}/) {
        warn "rejecting $rtr $desc\n" if($opts->{debug});
      return 0;
    }
    
    if($opts->{noshutdown} and $stat!=1)  {
        warn "ignoring shutdown interface $rtr $desc\n" if($opts->{debug});
        return 0;
    }
    
    if($speed==0) {
        warn "speed is zero, reject $rtr $desc\n" if($opts->{debug});
        return 0;
    }
    
    warn "Accepted interface\n" if($opts->{debug}>1);
    
    return 1;
}

sub GetAddresses {
    my($session)=(@_);
    my(%hash);
    my($vars)=new SNMP::VarList(
       ["ipAdEntAddr"],
       ["ipAdEntIfIndex"],
       ["ipAdEntNetMask"]
    );
    while(my($addr,$index,$mask) = $session->getnext($vars) and
          $vars->[0]->tag =~ /ipAdEntAddr/ and 
          not $session->{ErrorStr}) {
        my $net=inet_ntoa(inet_aton($addr)&inet_aton($mask)). "/" . 
            MaskLen($mask);      
        $hash{$index}=[$addr,$net];
    }
    warn "$session->{ErrorStr}\n" if($session->{ErrorStr});
    return wantarray ? %hash: {%hash};
}

sub MaskLen {
    my($mask)=unpack("N",inet_aton($_[0]));
    my($len)=32;
    while($mask && ($mask&1)==0) {
      $len--;
      $mask/=2;
    }
    return $len;
}


Main;







