#!/usr/bin/perl

use strict;
use CIBH::Config qw/ $default_options /;
use CIBH::Dia;
use CIBH::Logs;
use Getopt::Long;
use CIBH::File;

my $opts = $default_options;

use v5.14;

sub Main {

    GetOptions($opts,
               "shades=i",  # number of shades
               "log_path=s",    # where to find the usage logs
               "log_glob=s",     # what the log filenames look like
               "map_path=s",
               "chart_cgi=s",
               "usemin",    # usemin instead of max?
               "hide_urls", # hide lines with urls?
               "config=s",      # config file
               "data_path=s",   # base directory
               "debug:i",       # debug messages
               "stdout");


    $opts->{debug}=1 if(defined $opts->{debug} and $opts->{debug}==0);

    my $logs=CIBH::Logs->new( $opts );

    foreach my $input (@ARGV) {
        my $file= CIBH::File->new($input);
        warn "$!: $file\n", next if not defined $file;
        my $dia = CIBH::Dia->new($file, $opts->{debug});

        ProcessDia($dia, $logs);
        if(defined $opts->{stdout}) {
            print $dia->output;
        } else {
            ($input)=reverse(split(/\//,$input));
            my $fh=CIBH::File->new("$opts->{map_path}/$input.html");
            my $fh2=CIBH::File->new("$opts->{map_path}/$input.png");
            $fh < $dia->imgmap;
            $fh2 < $dia->png;
        }
    }
}

sub ProcessDia {
    my ($dia, $logs) = (@_);

    my $boxes = $dia->boxes;
    my $text = $dia->texts;

    for(@{$boxes}) {
        $_->text(HandleString($dia, $_, $_->text, $logs));
    }

    for(@{$text}) {
        $_->text(HandleString($dia, $_->line, $_->text, $logs));
    }
}

# All strings that started with # are processed special.  If the
# string starts with a #!, it is evaluated.  If the string is starst
# with a #< and ends with a >, then it is considered a url (which can
# be stripped, depending upon what the value of the nostrip option
# is).  Otherwise the string will be considered an regexp for filename
# matching.
# compound will be recolored (in the case of lines) or string replaced
# (in the case of ## strings) to contain the value retrieved from the
# file(s).  An automatic url ref will be added to back ref the html
# page associated with the matching file.  If multiple files match, a
# new page will be created that provides a simple link to each page.

sub HandleString {
    my ($dia,$obj,$lines,$logs)=(@_);
    state ($date, $adate, $cdate, $mdate);
    state %filehash;

    # reinitialize these if we're processing a new dia file
    if ($mdate ne $dia->mtime) {
        $date = localtime();
        $adate = $dia->atime;
        $cdate = $dia->ctime;
        $mdate = $dia->mtime;
    }


    my $output;
    my $util;
    my $url;

    foreach my $line (split(/\n/, $lines)) {
        my ($str) = ($line=~(/^\#(.*)$/));
        # pass the line unaltered if doesn't begin with hash
        if (!defined($str)) {
            $output .= "$line\n";
        } elsif ($str =~ /^\s+$/) {  # skip processing line if it's blank
        } elsif(my ($cmd)=($str=~/^!(\"?.*\"?)/)) {
            $output .=eval $cmd;
        } elsif(my ($u)=($str=~/^<(.*)>$/)) {
            $url = $u;  # user defined URL overrides generated URL
        } elsif($str=~/^#/) {
            $output .= "##\n";
        } else {  #assume str is a regexp - replace it with a url
            my $files;
            if (exists($filehash{$str})) {
                $files = $filehash{$str};
            } else {
                $files=$logs->GetFiles($str);
                $filehash{$str}=$files;
            }
            if(@{$files}==0) {
                undef $line;
                warn "Didn't match anything for $str\n";
            } else {
                $util=$logs->GetUtilization($files);
                UpdateColor($obj,$util);
                if (!defined($url)) {
                    $url=$opts->{chart_cgi}.(($opts->{chart_cgi}=~/\?/)?"&":"?").
                        "file=".join(",",@{$files});
                    $url.="&net=$opts->{network}" if(defined $opts->{network});
                }
            }
        }
    }
    $util=int($util);
    $output =~ s/##/$util/g if (defined($util));
    $obj->url = $url if (defined($url) && not $opts->{hide_urls});
    chomp $output;
    return $output;
}

sub ColorMap
{
    my($shades)=(@_);
    my($r,$g,$b)=(0,255,0);
    my($step)=255/$shades;
    my @colors;
    for(my $i=0;$i<$shades;$i++){
        push(@colors, sprintf("\#%02x%02x%02x",$r,$g,$b));
        ($r,$g,$b)=($r+$step,$g-$step,$b+2*$step*(($i>=$shades/2)?-1:1));
    }
    return \@colors;
}

# walk through the lines fixing any that need to be changed according
# to the value in util.
sub UpdateColor {
    my ($obj, $util) = (@_);
    state $colors;
    $colors ||= ColorMap($opts->{shades});

    my $color=$colors->[int($util*($opts->{shades}-.001)/100)];
    $obj->color($color);
}

Main();
exit 0;
