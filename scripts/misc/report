#!/usr/bin/perl

# Copyright (C) 1999 Peter Whiting
# This module is free software; you can redistribute it and/or
# modify it under the terms of the GNU Library General Public
# License as published by the Free Software Foundation; either
#  version 2 of the License, or (at your option) any later version.
#
# This module is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public
# License along with this library; if not, write to the
# Free Software Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.

use BarnSQL;
use Getopt::Long;
use IO::File;
use DataSet;

if (-r "$ENV{HOME}/.barnrc") {
    require "$ENV{HOME}/.barnrc";
}

# set the default values
%opts=(delay=>5,
       data_path=>".",
       delta=>3600*24*7,
       %default_options);

GetOptions(\%opts,
           "dbname=s",
           "user=s",
           "pswd=s",
           "stdin",
           "cpu",
           "data_path=s",
           "delta=i",
           "type=s",
           "max",
           "percent",
	   "cgi=s");

$db = new BarnSQL(\%opts) or die "Couldn't connect";

$stop=time;
$action=\&Interface;
$action=\&CPU if($opts{cpu});

if($opts{stdin}) {
  for(print "Router: ";<>;print "Router: ") {
      &{$action}($rtr);
  }
} else {
  %rtrs = $db->GetHosts;
  foreach $rtr (keys %rtrs)  {
      &{$action}($rtr);
  }
}

sub hsort { $vals{$b} <=> $vals{$a} }

foreach $key (sort hsort (keys %vals)) {
    print "$key $vals{$key}\n";
}
# only look at the active files.  Unfortunately, the only way to
# that is first pull all of the active mibs.  Each active mib
# has a filename associated with it.  Only look into these files.


sub CPU {
    my($rtr)=(@_);
    my(@inputs,$file,$data,$stop,@vals);
    my($scale)=($opts{percent}?.01:1);
    if(($file)=$db->GetFiles($rtr,"c",$scale)) {
        $vals{"$file"}=int(getval("$opts{data_path}/$file",1));
    }
}

sub Interface {
    my($rtr)=(@_);
    my($in,@inputs,$iface,$out,$desc,%hash);
    @inputs=sort($db->GetFiles($rtr,"i","in"));
    foreach $in (@inputs) {
	%hash=$db->GetFileInfo($in);
	$out=$in;
        $out=~s/in$/out/;
#	($iface,$outfile,$desc)=split(/\|/,$hash{info});
        my($scale,$adj)=(1,1);
        if($opts{percent}) {
            $scale=1/$hash{maxval};
            $adj=100;
        }
        $vals{"$in"}=int($adj*getval("$opts{data_path}/$in",$scale));
        $vals{"$out"}=int($adj*getval("$opts{data_path}/$out",$scale));
    }
}

sub getval() {
    my($file,$scale)=(@_);
    $scale=1 if(not $scale);
    my($data)=new DataSet(filename=>"$file",
                          scale=>$scale);
    $data->TimeWarp($stop-$opts{delta});
    my(@vals)=$data->NextValue($stop);
    return $vals[1] if($opts{showmax});
    return $vals[0];
}

$db->Disconnect;

